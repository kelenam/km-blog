---
title: The Importance of Good Code
date: 2020-02-18
slug: the-importance-of-good-code
tags:
  - JS
  - Book
  - BEJA
  - Daniel Li
  - Good Code
  - Technical Debt
---

### Technical Debt
**Technical debt**: Compounding lack of best practices, poor code quality and clarity that likely priortizes speed/bare-functionality over long-term use and readability. Plays on the analogy of financial debt, where you incur compound interest on your existing debts. The idea here is that 
- Likely emerges when the MVP becomes the production codebase.

> "Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves."  
> Alan Kay, creator of Smalltalk

- For development, repayment of Technical debt comes in the form of **refactoring**; trading a moderate increase in development speed now for a significant decrease later.

#### Causes of technical debt
- Lack of talent: inexeprienced devs
- Lack of time: Setting unreasonable deadlines
- Lack of Morale: constant changes and unclear path to success

The real problem lies in the reluctance to tackle technical debt, since the biggest cause of technical debt is the *existing technical debt*. Any new code that depends on the bad code will very soon become part of the technical debt and incur further debt down the line.


#### The Debt Spiral
Where the financial analogy fails is the true cost. If you're thinking of a 3% APR it's more akin to something like a 1500% API from a payday loan. This is because we don't know the interest rate or repayment period beforehand.
- Often the consequences of technical debt are close to immediate; therefore, by rushing, it may actually slow you down within the same development cycle. 
- Very hard to predict and quantify the short-term benefits of incurring technical debt.

#### Consequences of Technical Debt
- slower development speed
- more manpower (and thus money) to implement same amount of features
- More bugs, meaning poorer user experience and more personnel required for customer service.

#### Human Consequences
##### Technical debt leads to low Morale
- Most debs want to work on **greenfield** projects where they can develop new features rather than inherit **brownfield** projects riddled with bugs and technical debt.
- Can lead to resentment of those stuck fixing things instead of creating new thing since colleagues can gain valueable experience on more modern frameworks and stay market-relevant.
> Aside: Interesting to hear about Goog's dev process seems to reinforce this idea at least from that one blogger: https://mtlynch.io/solo-developer-year-2/

##### Consequences of low Morale
- lower productivity: work slower, longer breaks, less engaged in business.
- lower code quality: development is a creative process, unhappy devs will be less inspired/creative.
- highter turnover: unhappy devs will leave

##### Repaying technical debt through refactoring
How do we actually repay the technical debt?

We do this through **refactoring**, or making our code *cleaner without changing the existing behavior*.

Whilst no formal definition of "clean", here's an approximation:
- **Well-structured**: code should consist of modules, separated by domain
- **Well-documented**: For example, include unit tests, inline comments, automatically generated documentation, and `README` files.
- **Succinct**:L Be concise, but not to the point of obfuscation.
- **Well-formatted and readable**: Other developers must be able to review and work on the same code base, so it sould be easy to understand adn not deviate too far from well-established conventions.

Deviations from these best pratices are referred to as **code smells**. They are weaknesses within the code that violate well-established design patterns.

Therefore, refactoring is simply a process that moves the current code base from having a lot of code smells to one that is cleaner and less smelly.  

The important point here is that developers should be given time to refator, in fact it should be at the core part of any development process and be included in the time estimates that the developers provide.

#### Preventing Technical Debt
- Prevent is better than cure. Preventative care and maintenance is key. So what does that look like?

##### Informing the decision makers
- It's important for professional developets to understand the situation that they must work within. That is the **triple constraint** model.

##### The triple constraint
- The classical project management triangle (aka the triple constraint or iron triangle).
- Coined the popular saying: Time, Quality, Cost: Pick Two.
- Premise: Optimzing the project for one area would cause another area to suffer.
    - Time and Quality: You can design and build a high-quality platform quickly but you'll need to hire a lot of experienced debs which will be expensive.
    - Time and Cost: You can build quickly with inexperienced devs but the quality will suffer.
    - Quality and Cost: You can tell a few inexperienced debs to design and plan a platform propertly that can be of good quality but it its going to be slow.

- Other companies might stay be more competitive and capture FMA (first-mover advantage) which will manifest itself in the business decisions in the company the devs are working for. 
- To make things worse: managers and business owners are focused on more tangible, immediate results, reinforcing the desire for all 3.

##### The Fallcy of the triple constraint
- The fallacy here is that by neglecting quality and incurring debt, they'll eventualy be increasing both the time and cost requirements many times over.
- Therefore, it is the duty of the develop to inform the product manager and business owner of the unpredictable effects of incurring technical debt.
- DO this to prevent the worst-case scenario where the effort required to fix the code is greater than rewriting everything from scratch (aside: I think this is another something potential danger, making that judgment call, I feel like a lot of devs would prefer to rewrite the whole thing than to actaully try fixing it as an instinct which may or may not bias their path forward.) 

##### Refuse to develop
- If something is FUBAR it may be best to take the drastic approach of refusing to develop until refactoring is done.
- most business owners do not know what is best for them technically, which is why they hired you to make teh best possible technical deicions for thier business.

##### Don't be a hero
- It's not always the business owners fault, especially if you're not pushing back on unreaonable deadlines.
- You may think the business would appreciate you for going the extra mile but here are 4 things wrong with that way of thinking:
1. You may not actually complete the feature on time that ensuing business strategy may depend on having done.
2. You're establishing an unsustainable threshold: "You did it last time..."
3. Rushing through code will likely incur technical debt.
4. Resentment from other developers, increasing load/rush for everyone involved.

- There's a time to stick your head out to save a business, but by doing it too often you are actually hurting the team.
- Business owners would rather hear *it's not possible* a month in advance than a promise of *everything will be done that was not delivered.*

#### Defining Processes
Good code starts with good planning, design, and management and is maintained by good processes.
Problems can be mitigated with clear guidelines:
- Situations where incurring technical debt is appropriate, for example to meet a legal requirement such as GDPR compliance.
- Occasions when developers can expect to receieve time to repay these debts, e.g. before the next feature is started, or two weeks at the end of each quarter.
- The distribution of work on greenfield/brownfield projects within the team, e.g. with a rotation system.
- The **Definition of Done** - a list of criteria which must be met before a feature is considered "done", e.g. code passes all tests and is peer-reviewed and documentation is updated.

Software development paradigms such as Agile, and Waterfall, as well as implementations like Scrum and Kanban, provide different ways to enforce these processes.

### Fixing bugs
- TDD reduces prevalance of bugs, but there will still be edge cases we have overlooked. We can still apply TDD principles to bug fixing.
- In TDD when a bug is encountered is a treated the same way as a new feature. You'd first write a failing test to reproduce the bug , then update the code until the test passes.
- Having the bug documented as a test care ensures the bug stays fixed in the future, preventing regression.

### Benefits of TDD
- For most new devs, having tests in the code is an afterthought-- a luxury if time permits. But that they don't realize is: *everyone tests their code, consciously or otherwise.*
- After you've written a function you may use the console to check if it works, but what you are doing is simply **manually testing** a function that has already been implemented.
- The advantage of manually testing is that it requires no upfront costs--you just run the function and see if it works. However, the downside is that it cannot be automated, eating up more time in the long run.

#### Avoid manual tests
Instead, you should formallyu define these manual tests as code, in the form of **unit**, **integration**, and **end-to-end (E2E)** tests, among others.
- Formally defining tests has a highter upfront cost, however, we can use scripts/automation to automatically run the same test every time the code changes, making the cost to run it in the future essentially zero and thus eliminating the likelhood of regression.

- You will always need to test, so a little time now or a lot of time later?
- Testing pyramid, developed by Mike Cohn, shows you should have lots of unit tests (fast and cheap to run), fewer integration tests, and even fewer UI tests (more time consuming and more expensive to define and run.)

### Tests as Specification
What are the other benefits of writing tests before implementation (besides avoiding manual testing)?
- :star: It forces you to think about your requirements and break them down into atomic units.
- You can write each test case around a specific requirement. The end result is that the test cases form the specification for your feature.
- writing tests first helps you structure your code around the requirements not the other way around.
- Also helps to abide by **You Aren't Going to Need It Again (YAGNI)** which prevents you from implementing features that aren't actually needed.

### Tests as documentation
- Test cases can essentially act as code samples and form part of the documentation.

### Short Development Cycles
Because TDD focuses on a single functional block at a time, it's dev cycles are usually pretty short (minutes/hours). This means, small incremental changes can be made and released rapidly.

### Difficulties with TDD adoption
- **Inexperienced team**: TDD only works if the whole team adopts it. Many junior devs never learned to write tests. Good news is that it isn't too hard to learn.
- **Slower initial development speed**: TDD requires product owner to create specification doc and for the developers to write the tests b efore any functional code is written. Slower but in the pay now or pay interest later way.
- **Legacy Code**: Many legacy have incomplete or zero tests written for it. This is tricky because TDD means you write your tests first; if you already have all you code then its can't be TDD.
- **Slow tests**: TDD is only pratical when the tests can be run quickly (within a few seconds). If the test suite takes a few minutes to run, then developers would not receive quick enough feedback for those tests to be useful. 
    - The simplest way to mitigate this is by breaking the code into smaller modules and running tests on them individually.
    - However, some tests, such as large integration and UI tests are inevitably slow, sometimes these can only be run in CI environments which we will get to later.

### When not to use TDD
- TDD isn't a silver bullet
- TDD induces a high intial cost so might not be useful in projects that are simply **Proof-of-Concept (PoC)**. 
- Secondly, may not be useful when the product owner has not defined clear requirements (or does not want to), like in some startups where pivoting is likely. Writing tests may be a waste of time if your project ends up pivoting to something else entirely.

### Review Questions
1. What is technical debt?
    - What are some of its causes?
2. What is TDD and how can it help with technical debt?
3. What are some more benefits of TDD?
4. How can you incorporate TDD into your workflow?
5. What is Good Code and what are its benefits?