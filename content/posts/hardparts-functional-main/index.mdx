---
title: ðŸ“‘ Intro | Hard Parts - Functional
date: 2020-03-18
slug: hardparts-functional-main
tags:
  - JS
  - FEM
  - Will Sentence
  - Hard Parts
  - functional programming
---

### Course Overview

Explore the increasingly popular paradigm of functional programming in JavaScript! Youâ€™ll learn how to wield and manipulate functions to develop more readable, maintainable and manageable codebases. Youâ€™ll go under the hood of powerful techniques like: Higher Order Functions, Function Composition, Pure Functions, and Immutability of State.

Published: October 1, 2019

## Contents
- [Introduction]()
- [JavaScript Principles Review](/hardparts-functional-js-principles)
- [Higher Order Functions](/hardparts-functional-higher-order-functions)
- [Map & Reduce](/hardparts-functional-map-and-reduce)
- [Composition](/hardparts-functional-composition)
- [Purity & Immutability]()
- [Closure]()
- [Function Decoration & Partial Application]() 

## Intro

### Let's suppose we have a quiz game we're building
Every line of code either saves data to memory (e.g. a user's score) or uses that data (e.g. increase that user's score)

But with 1000s of lines of code - every line of code can potentially use (and **depend**) on that data

High risk - every time I want to change any line, I have to consider whether it could affect other lines (and when I miss something, I get bugs)

What's the answer?

### The answers have been *functions*

**Compartamentalise**: Reduce the potential impact of any given line to maybe 10 other lines (inside the function)

**But** even within a 10 line functions, 'reasoning' through what each line do esi shard - & the code may still have affects outside the function (via global varibales). They are also very imperatively written.

Functions we we know them may very well not be enough.

### Imagine if we could structure our code into individual pieces where *almost every single line* is self-contained
- The only thing any given line depends on are inputs (explicitly stated in that very line)
- The only consequences of the line would be its output (explicitly stated in that very line)
- *And* each line could get a nice human-readable label for when we use it!

This could transform how we write code, debug it and read about other's code.

But how could we do it?!

### Functional programming
With functional programming...  

**Tiny functions**: Save every single line ( or few lines) as its own function

**No consequences except on that lines**: Each function's only 'consequence' is to have its result given to specifically the next line of code ('function call') and not to any other lines

**Recombine/compose**: Build up our application by using these small blocks of self-contained code combining them up line-by-line by *referring to their human-readable name*.


## Functional Programming Benefits & Concepts

### We could produce a beautiful 'to do list' of our code
```js
pipe (
    getPlayerName,
    getFirstName,
    properCase,
    addUserLabel,
    createUserTemplate
)([{name: ' will sentence', score: 3 }]);
```
And render to the webpage.

### Functional programming techniques - How do we recombine?
Combining our functions is going to require a ton of interesting techniques to:
- rejoin these "lines" of code (tiny functions) into full-sized tasks:
    - make it easy to reuse these functions all over the place
    - ensure that they tiny functions truly are self-contained

### (1)  Higher Order Functions, (2) Function Composition
- A lot of these atoms of code (tiny fractions) will be resuable
    - they're small enough that they're tasks like incrementing a number, looping through an array
    - we want to write once, use again and again--even for tasks that are not quite identical--keeping our code DRY.

### (3) Pure functions, immutatability of state
We cannot have our lines of code rely on any external data except their explicitly stated inputs.

It's especially important when you're reusing/recombining lots of these little single-step functions in lots of totally different scenarios--they better be self contained!

### (4) Closure, (5) Function Decoration (6) Partial application & currying
We will need ways to:

- Adjust the functions in case they don't quite fit together as initially saved (with the help of closure)
- Give our functions extra features without having to write a new function from scratch (with the help of closure)

### If we can do all that, our code will become:
- **More readable** - every line of code has a name that indicates its goal known as 'declarative' programming
- **Easier to debug** - each line of code is an individual unit with clear input and output - no unexpected consequences of using that line ('function')
- **Easier to add features** - most new things we want to do are combinations of something we've done elsewhere in our app

### Our end and beginning
Functions become reusable, versatile, flexible pieces of code--a series of independent self-contained readable and predictable steps passing data from one to the next.

But it all starts with us being confident with the core principles of JavaScript.

## Links
- [MAIN](/hardparts-functional-main)
---- 
- [NEXT â†’ | JavaScript Principles Review](/hardparts-functional-js-principles)