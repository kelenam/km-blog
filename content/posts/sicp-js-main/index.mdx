---
title: Structure and Interpreation of Computer Programs - JavaScript Adaptation
date: 2020-02-20
slug: /sicp-js-main
tags:
  - JS
  - CS
  - SICP
  - ES6
  - ES6 Modules
---

### Preface
- Based off "Structure and Interpretation of Computer Programs" by Harold Abelson and Gerald Sussman
- introduces core programmatic concepts not beholden to any specific language
- OG text used Scheme, here the adaptation uses JS (specifically the source langs/subsets of js)

> More precisely, this adaptation uses five tiny, carefully designed, sublanguages of JavaScript. The languages are called *Source §1*, *Source §2*, *Source §3*, *Source §4* and *Source §5*, corresponding to the respective chapters 1, 2, 3, 4 and 5 of the textbook. The Source §1 language contains only constructs that are needed in the programs contained in chapter 1: constructs required to build abstractions with functions. Source §2 is a superset of Source §1; adding features required to build abstractions with data, on top of the features of Source §1. Similarly, Source §3, 4 and 5 extend the previous language features required to address the subject of the respective textbook chapter. All these languages are sub-languages of JavaScript; any Source program is also a JavaScript program. The reverse is not true. The JavaScript language has many features that are not covered in this textbook. Indeed, the Source languages are so small that they can be quite adequately described in a few pages of text. The online folder [source](https://sicp.comp.nus.edu.sg/source/) contains the specifications of the Source languages, as reference for the reader.

- Source Adacemy is the web-based programming env that will obligate readers to not use any constructures beyond the source langs.


### JavaScript Adaptation Making-of
Repo Link: https://github.com/source-academy/sicp
[PDF Edition](https://sicp.comp.nus.edu.sg/sicpjs.pdf)
[e-book edition](https://sicp.comp.nus.edu.sg/sicpjs.epub)

### Contents
1. [Building Abstractions with Functions](sicp-js-building-abstractions-with-functions)
    1. [The Elements of Programming](/sicp-js-elements-of-programming)
        1. Expressions
        1. Naming and the Environment
        1. Evaluating Operator Combinations
        1. Functions
        1. The Substitution Model for Function Application
        1. Conditional Expressions and Predicates
        1. Example: Square Roots be Newtons Method
        1. Functions as Black-Box Abstractions
    1. Functions and the Processes They Generate
        1. Linear Recursion and Interation 
        1. Tree Recursion
        1. Orders of Growth
        1. Exponentiation 
        1. Greatest Common Divisors
        1. Example: Testing for Primality
    1. Formulating Abstractions with Higher-Order Functions 
        1. Functions as Arguments
        1. Function Definition Expressions
        1. Functions as General Methods
        1. Functions as Returned Values
2. Building Abstractions with Data
    1. Introduction to Data Abstraction
        1. Example: Arithmetic Operators for Rational Numbers
        1. Abstraction Barriers
        1. What is Meant by Data?
        1. Extended Exercise: Interval Arithmetic
    1. Hierarchical Data and the Closure Property
        1. Representing Sequences 
        1. Hierarchical Structures
        1. Sequences as Conventional Interfaces
        1. Example: A Picture Language
    1. Symbolic Data
        1. Strings
        1. Example: Symbolic Differentiation
        1. Example: Representing Sets
        1. Example: Huffman Encoding Trees 
    1. Multiple Representations for Abstract Data
        1. Representations for Complex Numbers 
        1. Tagged data 
        1. Data-Directed Programming and Additivity
        1. Systems with Generic Operations 
    1. Systems with Generic Operations
        1. Generic Arithmetic Operations 
        1. Combining Data of Different Types
        1. Example: Symbolic Algebra
3. Modularity, Objects, and State
    1. Assignment and Local State 
        1. Local State Variables
        1. The Benefits of Introducing Assignment
        1. The Costs of Introducing Assignment
    1. The Environment Model of Evaluation
        1. The Rules of Evaluation
        1. Applying Simple Functions
        1. Frames as the Repository of Local State
        1. Internal Definitions 
    1. Modeling with Mutable Data
        1. Mutable List Structure
        1. Representing Queues
        1. Representing Tables
        1. A Simulator for Digital Circuits
        1. Propogation of Constraints
    1. Concurrency: Time Is of the Essence
        1. The Nature of Time in Concurrent Systems
        1. Mechanisms for Controlling Concurrency
    1. Streams
        1.Streams are Delayed Lists
        1. Infinite Streams
        1. Exploiting the Stream Paradigm
        1. Streams and Delayed Evaluation 
        1. Modularity of Functional Programs and Modularity of Objects 
4. Metalinguistic Abstraction
    1. The Metacircular Evaluator 
        1. The Core of the Evaluator
        1. Representing Statements and Expressions
        1. Evaluator Data Structures
        1. Running the Evaluator as a Program 
        1. Data as Programs
        1. Internal Declarations
        1. Separating Syntactic Analysis from Execution
    1. Lazy Evaluation
        1. Normal Order and Applicative Order
        1. An Interpreter with Lazy Evaluation
        1. Streams as Lazy Lists
    1. Nondeterministic Computing
        1. Amb and Search
        1. Examples of Nondeterministic Programs
        1. Implementing the amb Evaluator 
    1. Logic Programming 
        1. Deductive Information Retrieval
        1. How the Query System Works
        1. Is Logic Programming Mathematical Logic?
        1. Implementing the Query System
5. Computing with Register Machines
    1. Designing Register Machines 
        1. A Language for Describing Register Machines
        1. Abstraction in Machine Design 
        1. Subroutines 
        1. Using a Stack to Implement Recursion 
        1. Instruction Summary
    1. A Register-Machine Simulator 
        1. The Machine Model 
        1. The Assembler
        1. Generating Execution Functions for Instructions
        1. Monitoring Machine Performance
    1. Storage Allocation and Garbage Collection
        1. Memory as Vectors
        1. Maintaining the Illusion of Infinite Memory 
    1. The Explicit-Control Evaluator
        1. The Code of the Explicit-Control Evaluator
        1. Sequence Evaluation and Tail Recursion
        1. Conditionals, Assignments, and Definitions 
        1. Running the Evaluator 
    1. Compilation 
        1. Structure of the Compiler
        1. Compiling Expressions
        1. Compiling Combinations
        1. Combining Instruction Sequences
        1. An Example of Compiled Code
        1. Lexical Addressing 
        1. Interfacing Compiled Code to the Evaluator 
